#!/usr/bin/env python
# coding: utf-8

# # Single cell RNA sequencing of neural stem cells labeled with AAV1_P5

# Some abbreviations:
#
# NSC = neural stem cell
# aNSC = active NSC
# TAP = transit-amplifying progenitor cell
# NB = neuroblast
# PC(A) = principal component (analysis)
# UMAP = uniform manifold approximation and projection for dimension reduction

import scvelo as scv
import scanpy as sc
import pandas as pd
import numpy as np
import scipy.io
from anndata import AnnData
import matplotlib.pyplot as plt
import scrublet as scr


# these adata.h5ad files were generated by kallisto|bustools
h5ad_filepaths = [
    "sample_1/counts_unfiltered/adata.h5ad",
    "sample_2/counts_unfiltered/adata.h5ad",
]
ann_datas = []
for i, h5 in enumerate(h5ad_filepaths):
    sample_ad = scv.read(h5, cache=True)
    print('Loaded sample {} mtx: {} from file \n {}'.format(i+1, sample_ad.X.shape, h5))
    ann_datas.append(sample_ad)
ad = AnnData.concatenate(*ann_datas, join='inner', 
    batch_categories=["WT1", "WT2"], index_unique='-')
ann_datas = None
sample_ad = None


# Consider both spliced and unspliced mRNAs in our count matrix
ad.X = ad.layers["spliced"] + ad.layers["unspliced"]


# Add gene symbols to ad.var to help interpret the Ensembl gene IDs
# a gene ID map from Ensembl BioMart
idmap = pd.read_csv("mm10ensembl99_gene-id_to_gene-symbol.tsv",
                    sep="\t",
                    names=["gene_id", "gene_symbol"]).sort_values(by=["gene_id"])
id2symbol = {}
symbol2id = {}
for gene_id, symbol in zip(idmap["gene_id"].tolist(), idmap["gene_symbol"].tolist()):
    id2symbol[gene_id] = symbol
    symbol2id[symbol] = gene_id

gene_symbols = []
for gene_id_version in ad.var.index:
    gene_id = gene_id_version.split(".")[0]
    if gene_id in id2symbol:
        gene_symbols.append(id2symbol[gene_id])
    elif gene_id.startswith("ENSMUSG"):
        gene_symbols.append("NA")
    else:
        gene_symbols.append(gene_id.replace(".1", ""))

ad.var["gene_symbol"] = gene_symbols


# Calculate and plot a bunch of metadata such as mitochondrial read %, number of of UMIs per cell etc.
mito_genes = ad.var["gene_symbol"].str.startswith('mt-')
ad.obs['percent_mito'] = np.sum(
    100 * ad[:, mito_genes].X, axis=1).A1 / np.sum(ad.X, axis=1).A1
ad.obs['n_counts'] = ad.X.sum(axis=1).A1
ad.obs['n_UMIs'] = ad.obs['n_counts'].copy()
ad.obs['n_genes'] = (ad.X > 0).sum(axis=1).A1
ad.obs['percent_unspliced'] = 100 * np.sum(ad.layers["unspliced"], axis=1).A1 / np.sum(ad.X, axis=1).A1

sc.pl.violin(ad, ['n_genes', 'n_UMIs', 'percent_mito', 'percent_unspliced'],
             jitter=0.4, multi_panel=True)


# # Filter empty droplets and dead cells

# We use the infamous "knee-plot" to determine a threshold that roughly separates empty droplets and droplets containing a cell.
get_ipython().run_line_magic('matplotlib', 'inline')

n_UMI_cutoff = 1500  # our chosen threshold

plt.scatter(
    y = ad.obs.sort_values("n_UMIs", ascending=False)["n_UMIs"],
    x = np.arange(ad.obs.shape[0]),
    s=1, c=ad.obs['percent_mito'])
plt.xscale("log")
plt.yscale("log")
plt.xlim(1, 1e6)
plt.ylim(1, 1e5)

plt.axhline(y=n_UMI_cutoff)


# Filter all cells with less than 1500 UMIs and/or more than 15% mitochondrial reads (an indicator of apoptosis)
ad = ad[(ad.obs["n_UMIs"] >= n_UMI_cutoff) & (ad.obs["percent_mito"] <= 15), :]


# # Write the count matrix and metadata to files
# optionally: save the raw count matrix for use in e.g. Seurat
"""
outdir = "/path/to/write/output/files"

scipy.io.mmwrite(
    f"{outdir}/raw_counts_cellXgene.mtx",
    ad.X.astype(np.int_),
    comment = "4572 cells x 31059 genes, lineage tracing of adult NSCs of the murine SVZ using an AAV",
)
ad.var.to_csv(
    f"{outdir}/colNames_genes.tsv.gz",
    sep="\t",
    header=False)
pd.DataFrame(ad.obs.index).to_csv(
    f"{outdir}/rowNames_cellBarcodes.tsv.gz",
    sep="\t",
    header=False,
    index=False)
"""


# Plot again, it looks better now after we filtered the trash
sc.pl.violin(ad, ['n_genes', 'n_UMIs', 'percent_mito', 'percent_unspliced'],
             jitter=0.4, multi_panel=True)


# # Standard scRNA-seq workflow from raw counts to UMAP + clusters

# Normalize and log1p-transform our counts
sc.pp.normalize_total(ad, target_sum=1e4)
sc.pp.log1p(ad)

# Set the .raw attribute of AnnData object to the normalized and logarithmized raw gene expression 
# for later use in differential testing and visualizations of gene expression.
# This simply freezes the state of the AnnData object.
ad.raw = ad


# Find highly variable genes with scanpy
sc.pp.highly_variable_genes(ad)
sc.pl.highly_variable_genes(ad)

# number of selected highly variable genes
sum(ad.var.highly_variable)


# Only keep highly variable genes
ad = ad[:, ad.var.highly_variable]


# Calculate the first 50 PCs and neighbor graph on these PCs
scv.pp.moments(ad, n_pcs=50, n_neighbors=35)


# Calculate 2D UMAP coordinates on the neighbor graph
sc.tl.umap(ad)


# Cluster the cells with the Leiden algorithm (improved version of Louvain algorithm).
# We set the resolution a bit lower cause otherwise we get very many clusters that surely don't represent actual cell types.
sc.tl.leiden(ad, resolution=.5)


# ## Plot the UMAP, coloring cells by different attributes
sc.pl.umap(ad, color = ["n_UMIs", "n_genes", "percent_mito", "leiden", "ENSMUSG00000031004.8"], size=4, ncols=1)


# We can clearly see that cells do not travel down straight trajectory. Instead, there seems to be a pretty distinct cellular state at the very left of this UMAP. Highlighting the expression of MKi67 (proliferation marker, last plot) clearly suggests that this state might be related to cell division.
# again, optionally export this metadata
"""
ad.obs.to_csv(
    f"{outdir}/cell_metadata.tsv.gz",
    sep="\t")
pd.DataFrame(ad.obsm["X_pca"]).to_csv(
    f"{outdir}/PCA.tsv.gz",
    sep="\t",
    index=False,
    header=False)
pd.DataFrame(ad.obsm["X_umap"]).to_csv(
    f"{outdir}/UMAP.tsv.gz",
    sep="\t",
    index=False,
    header=False)
"""


# ## Regress out the effects of the cell cycle on gene expression

# Define lists of cell cycle stage markers (from the scanpy docs)
g2m_genes = ('Gas2l3', 'Nek2', 'Hmgb2', 'Cdca2', 'Cdk1', 'Kif11', 'Kif2c', 'Ube2c', 'Smc4', 'Birc5', 'Pimreg',
             'Cks2', 'Tpx2', 'Cdca8', 'Kif23', 'Ncapd2', 'Ckap2', 'Ndc80', 'Tubb4b', 'Ckap5', 'Tacc3', 'Top2a',
             'Cdc25c', 'Rangap1', 'Aurkb', 'Anp32e', 'Ctcf', 'Bub1', 'Nusap1', 'Ccnb2', 'Psrc1', 'Mki67',
             'Cenpe', 'Ckap2l', 'G2e3', 'Cdca3', 'Ect2', 'Gtse1', 'Ttk', 'Cdc20', 'Dlgap5', 'Cenpf', 'Nuf2',
             'Hmmr', 'Hjurp', 'Anln', 'Cks1b', 'Aurka', 'Lbr', 'Kif20b', 'Tmpo', 'Cenpa', 'Cbx5')
g2m_genes = ad.var[ad.var["gene_symbol"].isin(g2m_genes)].index.tolist()
s_genes = ('Cdca7', 'Dtl', 'Exo1', 'Rfc2', 'Ubr7', 'Gmnn', 'Mcm5', 'Ccne2', 'Mcm4', 'Tipin', 'Rrm2', 'Pola1',
           'Chaf1b', 'Msh2', 'Tyms', 'Rad51', 'Casp8ap2', 'Blm', 'Pcna', 'Brip1', 'Uhrf1', 'Cdc6', 'Cenpu',
           'Slbp', 'Prim1', 'Rrm1', 'Fen1', 'Mcm6', 'Hells', 'Clspn', 'E2f8', 'Usp1', 'Polr1b', 'Rad51ap1',
           'Mcm2', 'Pold3', 'Gins2', 'Nasp', 'Wdr76', 'Dscc1', 'Mrpl36', 'Cdc45', 'Ung', 'Rpa2', 'Mcm7')
s_genes = ad.var[ad.var["gene_symbol"].isin(s_genes)].index.tolist()


# Score cells according to their expression of these markers. This roughly classifies cells by cell cycle phase.
sc.tl.score_genes_cell_cycle(ad, s_genes, g2m_genes)


# Plotting our predicted scores reveals that the weird cells on the left indeed seem to be actively cycling. They are probably mostly TAPs and some aNSCs and NBs.
sc.pl.umap(ad, color=["phase", "S_score", "G2M_score"], size=3, ncols=1)


# So now that we have established that cell cycle is a very dominant effect in our transcriptomes, let's try to reduce it's impact on the data. First, we revert to the unfiltered dataset and regress out the effects of the cell cycle. Then we start from scratch, but this time with the cell-cycle-adjusted expression matrix.
ad = ad.raw.to_adata()

sc.pp.regress_out(ad, ['S_score', 'G2M_score'])


# # Standard scRNA-seq analysis, but this time after regressing effects of the cell cycle

# Now we start again just like before: Find highly variable genes -> PCA -> neighbor graph -> UMAP -> clustering
sc.pp.highly_variable_genes(ad)
sc.pl.highly_variable_genes(ad)

# number of selected highly variable genes
sum(ad.var.highly_variable)


# Only keep highly variable genes
ad = ad[:, ad.var.highly_variable]


sc.tl.pca(ad, svd_solver='arpack')
sc.pp.neighbors(ad, n_neighbors=35, n_pcs=50)


sc.tl.umap(ad)


sc.pl.umap(ad, color = ["n_UMIs", "n_genes", "percent_mito", "leiden", "phase"], size=4, ncols=1)


# The cycling cells still mostly group together, but the overall effect is greatly reduced.
# The leiden clusters have to be re-calculated of course.
sc.tl.leiden(ad, resolution=.4)


sc.pl.umap(ad, color = ["leiden"], size=4, ncols=1)


# optionally, write these now metadata to files
"""
outdir = "/mnt/volume/tmp"
pd.DataFrame(ad.obsm["X_umap"]).to_csv(
    f"{outdir}/UMAP_noCellCycle.tsv.gz",
    sep="\t",
    index=False,
    header=False)

ad.obs["leiden"].to_csv(
    f"{outdir}/clustering_noCellCycle.tsv",
    sep="\t", header=False)
"""


## The rest of the analysis continues in the R-script "02_scRNA-seq-analysis.Rmd"
